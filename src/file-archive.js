import DataroomElement from "dataroom-js";
import { downloadZip } from "client-zip";

// Note: For importing ZIPs, we use the `unzipit` package.
// This enables reading entries directly from a File/Blob without a server.
import { unzip } from "unzipit";

/**
 * File Archive Component
 *
 * A component that provides ZIP archive export and import functionality for FileClerk.
 * Can export all stored files into a downloadable ZIP archive and import files from
 * ZIP archives back into FileClerk storage.
 *
 * @class FileArchive
 * @extends DataroomElement
 * 
 * @example
 * // HTML usage:
 * <file-archive target="#file_clerk" verbose></file-archive>
 * 
 * // JavaScript usage:
 * const archive = document.querySelector('file-archive');
 * await archive.exportArchive(); // Downloads ZIP
 * await archive.importArchive(zipFile); // Imports from ZIP
 */
class FileArchive extends DataroomElement {
  /**
   * Initializes the file archive component
   * Sets up the target FileClerk selector and creates UI controls if verbose
   * @returns {Promise<void>}
   */
  async initialize() {
    // Attach minimal UI (when verbose) for exporting/importing archives
    const targetSelector = this.getAttribute("target") || "#file_clerk";
    this._targetSelector = targetSelector;

    if (this.hasAttribute("verbose")) {
      this.innerHTML = "";
      
      const container = this.create("div", {
        style: "display: flex; gap: 0.5rem; align-items: center;"
      });

      const exportBtn = this.create("button", {
        content: "Export ZIP"
      }, container);
      
      exportBtn.addEventListener("click", () => this.exportArchive());

      const importBtn = this.create("button", {
        content: "Import ZIP"
      }, container);

      const fileInput = this.create("input", {
        type: "file",
        accept: ".zip",
        style: "display: none;"
      }, container);
      
      importBtn.addEventListener("click", () => fileInput.click());

      fileInput.addEventListener("change", async () => {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        try {
          await this.importArchive(file);
          this.log("Import complete");
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
        } finally {
          fileInput.value = "";
        }
      });
    }
  }

  /**
   * Gets the FileClerk element this archive component is targeting
   * @returns {HTMLElement|null} The FileClerk element or null if not found
   */
  get fileClerk() {
    const sel = this._targetSelector || "#file_clerk";
    return document.querySelector(sel);
  }

  /**
   * Exports all files from FileClerk into a single ZIP archive for download
   * Creates a manifest with file metadata and packages files into a downloadable ZIP
   * @returns {Promise<void>}
   * @throws {Error} When FileClerk is not found or not ready
   */
  async exportArchive() {
    const clerk = this.fileClerk;
    if (!clerk || typeof clerk.listFiles !== "function") {
      throw new Error("File Clerk not found or not ready");
    }

    const files = await clerk.listFiles();

    // Prepare manifest describing the entries (including MIME types for accurate restore)
    const manifest = {
      version: 1,
      generatedAt: new Date().toISOString(),
      files: files.map((f) => ({
        id: f.id,
        filename: f.filename,
        metadata: f.metadata,
        mimeType: this.parseMimeFromDataUrl(f.contents) || undefined,
      })),
    };

    // Convert each stored Data URL to a Blob for zipping
    const zipEntries = await Promise.all(
      files.map(async (f) => {
        const blob = await this.dataUrlToBlob(f.contents);
        const safeName = f.filename || "file";
        const name = `files/${f.id}/${safeName}`;
        return { name, input: blob, lastModified: new Date() };
      })
    );

    // Add manifest.json to the root of the archive
    zipEntries.push({
      name: "manifest.json",
      input: new Blob([JSON.stringify(manifest, null, 2)], { type: "application/json" }),
      lastModified: new Date(),
    });

    const zipBlob = await downloadZip(zipEntries).blob();
    this.triggerDownload(zipBlob, `file-clerk-archive-${this.timestamp()}.zip`);
  }

  /**
   * Imports all files from a ZIP archive generated by exportArchive()
   * Reads the manifest and restores files with their original metadata
   * @param {File|Blob} fileOrBlob - The ZIP file or Blob to import
   * @returns {Promise<void>}
   * @throws {Error} When FileClerk is not found or not ready
   */
  async importArchive(fileOrBlob) {
    const clerk = this.fileClerk;
    if (!clerk || typeof clerk.saveFile !== "function") {
      throw new Error("File Clerk not found or not ready");
    }

    // Unzip the archive
    const { entries } = await unzip(fileOrBlob);

    // Try to read manifest first
    const manifestEntry = entries["manifest.json"]; // exact root path
    let manifest = null;
    if (manifestEntry) {
      const text = await manifestEntry.text();
      manifest = JSON.parse(text);
    }

    if (manifest && Array.isArray(manifest.files)) {
      // Import using manifest metadata
      for (const item of manifest.files) {
        const path = `files/${item.id}/${item.filename || "file"}`;
        const entry = entries[path];
        if (!entry) {
          console.warn(`Missing entry in archive: ${path}`);
          continue;
        }
        const blob = await entry.blob();
        const rawDataUrl = await this.blobToDataUrl(blob);
        const corrected = this.ensureDataUrlMime(rawDataUrl, item.mimeType);
        await clerk.saveFile(item.filename, corrected, item.metadata);
      }
    } else {
      // Fallback: import all entries under files/** (no metadata)
      const paths = Object.keys(entries).filter((p) => p.startsWith("files/") && !p.endsWith("/"));
      for (const p of paths) {
        const entry = entries[p];
        const parts = p.split("/");
        const filename = parts.slice(-1)[0] || "file";
        const blob = await entry.blob();
        const rawDataUrl = await this.blobToDataUrl(blob);
        const guessedMime = this.guessMimeFromFilename(filename);
        const corrected = this.ensureDataUrlMime(rawDataUrl, guessedMime);
        await clerk.saveFile(filename, corrected, {});
      }
    }

    // Re-render if the clerk is verbose
    if (clerk.hasAttribute && clerk.hasAttribute("verbose") && typeof clerk.renderFileList === "function") {
      await clerk.renderFileList();
    }
  }

  /**
   * Utility Methods for File Archive Operations
   */

  /**
   * Converts a Data URL to a Blob object
   * @param {string} dataUrl - The Data URL to convert
   * @returns {Promise<Blob>} The resulting Blob
   */
  async dataUrlToBlob(dataUrl) {
    const res = await fetch(dataUrl);
    return await res.blob();
  }

  /**
   * Converts a Blob to a Data URL string
   * @param {Blob} blob - The Blob to convert
   * @returns {Promise<string>} The resulting Data URL
   */
  async blobToDataUrl(blob) {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  /**
   * Parses the MIME type from a Data URL
   * @param {string} dataUrl - The Data URL to parse
   * @returns {string} The MIME type or empty string if not found
   */
  parseMimeFromDataUrl(dataUrl) {
    const m = /^data:([^;]+);/i.exec(dataUrl || "");
    return m ? m[1] : "";
  }

  /**
   * Ensures a Data URL has the correct MIME type
   * @param {string} dataUrl - The Data URL to modify
   * @param {string} desiredMime - The desired MIME type
   * @returns {string} The Data URL with corrected MIME type
   */
  ensureDataUrlMime(dataUrl, desiredMime) {
    if (!desiredMime) return dataUrl;
    const currentMime = this.parseMimeFromDataUrl(dataUrl);
    if (currentMime && currentMime !== "application/octet-stream") return dataUrl;
    // Replace the header to enforce the desired MIME
    return dataUrl.replace(/^data:[^;]*;base64,/, `data:${desiredMime};base64,`);
  }

  /**
   * Guesses MIME type from filename extension
   * @param {string} filename - The filename to analyze
   * @returns {string} The guessed MIME type or empty string
   */
  guessMimeFromFilename(filename = "") {
    const ext = filename.split(".").pop().toLowerCase();
    switch (ext) {
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "png":
        return "image/png";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      case "mp4":
        return "video/mp4";
      case "mp3":
        return "audio/mpeg";
      case "wav":
        return "audio/wav";
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "json":
        return "application/json";
      default:
        return "";
    }
  }

  /**
   * Triggers a file download by creating a temporary download link
   * @param {Blob} blob - The Blob to download
   * @param {string} filename - The filename for the download
   * @returns {void}
   */
  triggerDownload(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = this.create("a", {
      href: url,
      download: filename,
      style: "display: none;"
    }, document.body);
    
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  /**
   * Generates a timestamp string for file naming
   * @returns {string} Formatted timestamp in YYYY-MM-DD_HH-MM-SS format
   */
  timestamp() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
  }
}

customElements.define("file-archive", FileArchive);