import DataroomElement from "../dataroom.js";
import { downloadZip } from "client-zip";

// Note: For importing ZIPs, we use the `unzipit` package.
// This enables reading entries directly from a File/Blob without a server.
import { unzip } from "unzipit";

class FileArchive extends DataroomElement {
  async initialize() {
    // Attach minimal UI (when verbose) for exporting/importing archives
    const targetSelector = this.getAttribute("target") || "#file_clerk";
    this._targetSelector = targetSelector;

    if (this.hasAttribute("verbose")) {
      this.innerHTML = "";
      const container = document.createElement("div");
      container.style.display = "flex";
      container.style.gap = "0.5rem";
      container.style.alignItems = "center";

      const exportBtn = document.createElement("button");
      exportBtn.textContent = "Export ZIP";
      exportBtn.addEventListener("click", () => this.exportArchive());

      const importBtn = document.createElement("button");
      importBtn.textContent = "Import ZIP";
      importBtn.addEventListener("click", () => fileInput.click());

      const fileInput = document.createElement("input");
      fileInput.type = "file";
      fileInput.accept = ".zip";
      fileInput.style.display = "none";
      fileInput.addEventListener("change", async () => {
        const file = fileInput.files && fileInput.files[0];
        if (!file) return;
        try {
          await this.importArchive(file);
          this.log("Import complete");
        } catch (err) {
          console.error(err);
          alert(`Import failed: ${err.message || err}`);
        } finally {
          fileInput.value = "";
        }
      });

      container.appendChild(exportBtn);
      container.appendChild(importBtn);
      container.appendChild(fileInput);
      this.appendChild(container);
    }
  }

  get fileClerk() {
    const sel = this._targetSelector || "#file_clerk";
    return document.querySelector(sel);
  }

  // Export all files from FileClerk into a single ZIP the user can download
  async exportArchive() {
    const clerk = this.fileClerk;
    if (!clerk || typeof clerk.listFiles !== "function") {
      throw new Error("File Clerk not found or not ready");
    }

    const files = await clerk.listFiles();

    // Prepare manifest describing the entries (including MIME types for accurate restore)
    const manifest = {
      version: 1,
      generatedAt: new Date().toISOString(),
      files: files.map((f) => ({
        id: f.id,
        filename: f.filename,
        metadata: f.metadata,
        mimeType: this.parseMimeFromDataUrl(f.contents) || undefined,
      })),
    };

    // Convert each stored Data URL to a Blob for zipping
    const zipEntries = await Promise.all(
      files.map(async (f) => {
        const blob = await this.dataUrlToBlob(f.contents);
        const safeName = f.filename || "file";
        const name = `files/${f.id}/${safeName}`;
        return { name, input: blob, lastModified: new Date() };
      })
    );

    // Add manifest.json to the root of the archive
    zipEntries.push({
      name: "manifest.json",
      input: new Blob([JSON.stringify(manifest, null, 2)], { type: "application/json" }),
      lastModified: new Date(),
    });

    const zipBlob = await downloadZip(zipEntries).blob();
    this.triggerDownload(zipBlob, `file-clerk-archive-${this.timestamp()}.zip`);
  }

  // Import all files from a ZIP archive generated by exportArchive()
  async importArchive(fileOrBlob) {
    const clerk = this.fileClerk;
    if (!clerk || typeof clerk.saveFile !== "function") {
      throw new Error("File Clerk not found or not ready");
    }

    // Unzip the archive
    const { entries } = await unzip(fileOrBlob);

    // Try to read manifest first
    const manifestEntry = entries["manifest.json"]; // exact root path
    let manifest = null;
    if (manifestEntry) {
      const text = await manifestEntry.text();
      manifest = JSON.parse(text);
    }

    if (manifest && Array.isArray(manifest.files)) {
      // Import using manifest metadata
      for (const item of manifest.files) {
        const path = `files/${item.id}/${item.filename || "file"}`;
        const entry = entries[path];
        if (!entry) {
          console.warn(`Missing entry in archive: ${path}`);
          continue;
        }
        const blob = await entry.blob();
        const rawDataUrl = await this.blobToDataUrl(blob);
        const corrected = this.ensureDataUrlMime(rawDataUrl, item.mimeType);
        await clerk.saveFile(item.filename, corrected, item.metadata);
      }
    } else {
      // Fallback: import all entries under files/** (no metadata)
      const paths = Object.keys(entries).filter((p) => p.startsWith("files/") && !p.endsWith("/"));
      for (const p of paths) {
        const entry = entries[p];
        const parts = p.split("/");
        const filename = parts.slice(-1)[0] || "file";
        const blob = await entry.blob();
        const rawDataUrl = await this.blobToDataUrl(blob);
        const guessedMime = this.guessMimeFromFilename(filename);
        const corrected = this.ensureDataUrlMime(rawDataUrl, guessedMime);
        await clerk.saveFile(filename, corrected, {});
      }
    }

    // Re-render if the clerk is verbose
    if (clerk.hasAttribute && clerk.hasAttribute("verbose") && typeof clerk.renderFileList === "function") {
      await clerk.renderFileList();
    }
  }

  // Utilities
  async dataUrlToBlob(dataUrl) {
    const res = await fetch(dataUrl);
    return await res.blob();
  }

  async blobToDataUrl(blob) {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  }

  parseMimeFromDataUrl(dataUrl) {
    const m = /^data:([^;]+);/i.exec(dataUrl || "");
    return m ? m[1] : "";
  }

  ensureDataUrlMime(dataUrl, desiredMime) {
    if (!desiredMime) return dataUrl;
    const currentMime = this.parseMimeFromDataUrl(dataUrl);
    if (currentMime && currentMime !== "application/octet-stream") return dataUrl;
    // Replace the header to enforce the desired MIME
    return dataUrl.replace(/^data:[^;]*;base64,/, `data:${desiredMime};base64,`);
  }

  guessMimeFromFilename(filename = "") {
    const ext = filename.split(".").pop().toLowerCase();
    switch (ext) {
      case "jpg":
      case "jpeg":
        return "image/jpeg";
      case "png":
        return "image/png";
      case "gif":
        return "image/gif";
      case "webp":
        return "image/webp";
      case "mp4":
        return "video/mp4";
      case "mp3":
        return "audio/mpeg";
      case "wav":
        return "audio/wav";
      case "pdf":
        return "application/pdf";
      case "txt":
        return "text/plain";
      case "json":
        return "application/json";
      default:
        return "";
    }
  }

  triggerDownload(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  timestamp() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}_${pad(d.getHours())}-${pad(d.getMinutes())}-${pad(d.getSeconds())}`;
  }
}

customElements.define("file-archive", FileArchive);